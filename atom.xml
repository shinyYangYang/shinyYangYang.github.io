<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果您发现问题请通知我</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-13T08:19:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime在项目中的使用(二)-自定义KVO</title>
    <link href="http://yoursite.com/2017/06/12/runtime%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89KVO/"/>
    <id>http://yoursite.com/2017/06/12/runtime在项目中的使用-二-自定义KVO/</id>
    <published>2017-06-12T10:01:30.000Z</published>
    <updated>2017-06-13T08:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVO的原理"><a href="#KVO的原理" class="headerlink" title="KVO的原理"></a>KVO的原理</h2><p>KVO观察者模式, 指定对象的属性被修改后, KVO就会自动通知相应的观察者. 在项目中的使用步骤可以归纳为三步:</p>
<ol>
<li><p>注册需要观察的对象的属性<br><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</code></p>
</li>
<li><p>实现回调方法, 当监测的值发生变化时候会回调该方法.<br><code>- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</code></p>
</li>
<li><p>取消注册观察者.<br><code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context</code></p>
</li>
</ol>
<p>基本的使用方法不用多说了. 直接来介绍苹果的实现原理以及自实现的步骤.</p>
<p>####苹果实现原理<br>当你注册观察一个对象时候, 一个新的继承于你观察的类被动态创建, 并且重写setter方法. 然后会把这个对象的isa指针指向新创建的类, 这个时候如果再改变其属性就会调用刚刚创建类的setter方法了. 这时候再在setter方法中存储属性的值和调用回调的方法.</p>
<pre><code>- (void)YYKVO_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context
{
    // 获取setter方法
    SEL setterSelector = NSSelectorFromString(setterForGetter(keyPath));
    Method setterMethod = class_getInstanceMethod([self class], setterSelector);
    if (!setterMethod) {
        NSLog(@&quot;没有找到set方法, 可能没有该属性, 无法绑定&quot;);
        return;
    }

    // 组建需要动态创建子类的类名
    NSString *oldClassName = NSStringFromClass([self class]);
    NSString *newName = [@&quot;YY&quot; stringByAppendingString:oldClassName];
    const char *newClassName = [newName UTF8String];

    // 添加一个类
    Class newClass = objc_allocateClassPair([self class], newClassName, 0);
    objc_registerClassPair(newClass);

    // 为新创建的类 添加setter方法
    class_addMethod(newClass, setterSelector, (IMP)YYKVO_setter_super, &quot;v@:@&quot;);

    // 改变self的isa指针, 指向创建的子类
    object_setClass(self, newClass);

    // 关联observe 和 self, 用于在回调方法使用
    objc_setAssociatedObject(self, (__bridge const void *)@&quot;YYKOVObserver&quot;, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre><blockquote>
<ol>
<li>组建set方法的名称, 然后获取其setter方法, 如果传入的keyPath出错, 没有该属性, 那么后面的内容就不必要存在.</li>
<li>动态创建子类, 新的子类继承当前类<code>Class newClass = objc_allocateClassPair([self class], newClassName, 0);</code>, 注册新类让系统知道.</li>
<li>重写setter方法, 为新的类添加setter方法.<br>`BOOL class_addMethod(Class cls, SEL name, IMP imp, <pre><code>const char *types)`                             
</code></pre><ol>
<li>Class cls :  指定类, 为我们的新创建的类newClass</li>
<li>SEL name :  方法名称.</li>
<li>IMP imp :  函数指针. </li>
<li>设置返回值和参数. 苹果的说明: An array of characters that describe the types of the arguments to the method. For possible values, see Objective-C Runtime Programming Guide &gt; <a href="xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/content/1189/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100" target="_blank" rel="external">Type Encodings</a>. Since the function must take at least two arguments—self and _cmd, the second and third characters must be “@:” (the first character is the return type). 苹果文档中有份表格说明了不同符号的意义. 比如这里的:<ol>
<li>V: A void 表示返回为空;</li>
<li>@: An object (whether statically typed or typed id) 这里传入的就是self,</li>
<li>: 表示A method selector (SEL),也就是_cmd.</li>
<li>@ 有表示id类型.</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<pre><code>这里说明下, 方法名称(SEL name) 和 函数指针(IMP imp) 指向的函数名不必一致, 很明显如果要求一致就不会需要两个参数了. 
</code></pre><p>  接下来就是实现 <code>YYKVO_setter_super</code>函数, 这里我写了两个类似的函数, 区别是一个直接调用<code>objc_msgSendSuper()</code>函数, 一个用<code>objc_msgSend()</code>先看<code>YYKVO_setter</code></p>
<pre><code>void YYKVO_setter (id self, SEL _cmd, id newValue)
{
    id class = [self class];
    // 改变self的isa指向super
    object_setClass(self, class_getSuperclass([self class]));

       // 获取到更改前属性的值
    NSString *setterName = NSStringFromSelector(_cmd);
    NSString *getName = getterForSetter(setterName);
    id oldValue = [self valueForKey:getName];

    // 更该属性的值
    SEL setSelector = NSSelectorFromString(setterName);
    objc_msgSend(self, setSelector, newValue);

    // 调用回调方法
    id observer = objc_getAssociatedObject(self, (__bridge const void *)@&quot;YYKOVObserver&quot;);
    objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), self, @&quot;name&quot;, @{@&quot;oldValue&quot; : oldValue, @&quot;newValue&quot; : newValue}, nil);

    // 更改self的isa指向新创建的子类
    object_setClass(self, class);
}
</code></pre><blockquote>
<p>改变self的isa指向父类, 所以这时候self就变成了我们指定监测的类了. 最后再换回来<code>object_setClass(self, class);</code>不然self的指针还是指向父类, 当下次属性在发生改变时候, 就不会调用我们指定的setter方法了.</p>
</blockquote>
<pre><code>void YYKVO_setter_super (id self, SEL _cmd, id newValue)
{
    NSString *setterName = NSStringFromSelector(_cmd);
    NSString *getName = getterForSetter(setterName);

    id oldValue = [self valueForKey:getName];

    struct objc_super superClass = {

        .receiver = self,
        .super_class = class_getSuperclass([self class])
    };
    objc_msgSendSuper(&amp;superClass, _cmd, newValue);

    id observer = objc_getAssociatedObject(self, (__bridge const void *)@&quot;YYKOVObserver&quot;);
    objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), self , @&quot;name&quot;, @{@&quot;oldValue&quot; : oldValue, @&quot;newValue&quot; : newValue}, nil);
}
</code></pre><blockquote>
<p>没有去改变self的isa指针, 而是直接使用了<code>objc_msgSendSuper()</code>函数, 这个函数需要传入一个结构体就是我们组建的superClass结构体. <code>objc_super</code> : Specifies the superclass of an instance. 里面包含两个元素:</p>
<blockquote>
<p>var receiver: Unmanaged<anyobject>!<br>    A pointer of type objc_object. Specifies an instance of a class.</anyobject></p>
<p>var super_class: AnyClass!<br>    A pointer to a Class data structure. Specifies the particular superclass of the instance to message.</p>
</blockquote>
<p>在最后调用回调方法时候, 会存在一个问题self这个时候还是指向我们创建的子类的.</p>
</blockquote>
<p>有个很有意思的地方, 我在调用回调方法时候, 并没有判断observer是不是实现了<code>@selector(observeValueForKeyPath:ofObject:change:context:)</code> 如果没有实现, 这样调用就会crash. 其实我想过通过判断修改成这样:</p>
<pre><code>Method observeValueForKeyPathMethod = class_getInstanceMethod([observer class], @selector(observeValueForKeyPath:ofObject:change:context:));
if (observeValueForKeyPathMethod) {
        objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), self , getName, @{@&quot;oldValue&quot; : oldValue, @&quot;newValue&quot; : newName}, nil);
    }
</code></pre><p>但是if的判断为真, 到这里感觉无法进行下去了, 所以去测试下苹果原生的看他是否存在这个问题. 去测试了下, 如果添加了观察者, 但是observer在没有实现回调方法的情况下一样会crash. 查了添加观察者方法中的说明, 在说明observer时候指出</p>
<blockquote>
<p>observer :</p>
<blockquote>
<pre><code>The object to register for KVO notifications. The observer **must implement the key-value     observing method observeValueForKeyPath:ofObject:change:context:**.
</code></pre></blockquote>
</blockquote>
<p>所以, 说明苹果原生的也没能解决这个问题(当存在继承关系时候, 无法判断到底是那个类实现了该方法), 我们大概能够猜测在NSObject类中有这样的实现. </p>
<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context
{
    NSlog(@&quot; 子类必须实现&quot;);
    crash!!!;
}
</code></pre><blockquote>
<p>就是这个意思啊, 肯定苹果还干了很多别的事. </p>
</blockquote>
<p>有两个函数<code>setterForGetter()</code> 和 <code>getterForSetter()</code> 我用了硬编码的方式实现了, 肯定是能优化的. 在最后我会写出来. </p>
<h2 id="用block的方式"><a href="#用block的方式" class="headerlink" title="用block的方式:"></a>用block的方式:</h2><p>其实原理很简单, 上面我们关联了一个对象observer, 现在我们observer 和 传入的block一起关联保存下来, 在setter方法中调用block.</p>
<pre><code>- (void)YYKVO_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath withBlock:(YYObserverBlock)block
{
    SEL setterSelector = NSSelectorFromString(setterForGetter(keyPath));
    Method setterMethod = class_getInstanceMethod([self class], setterSelector);
    if (!setterMethod) {
        NSLog(@&quot;没有找到set方法, 所以可能没有该属性, 无法绑定&quot;);
        return;
    }
    NSString *oldClassName = NSStringFromClass([self class]);
    NSString *newName = [@&quot;YY&quot; stringByAppendingString:oldClassName];
    const char *newClassName = [newName UTF8String];

    Class newClass = objc_allocateClassPair([self class], newClassName, 0);
    objc_registerClassPair(newClass);

    class_addMethod(newClass, setterSelector, (IMP)YYKVO_setter_block, &quot;v@:@&quot;);
    object_setClass(self, newClass);

    NSDictionary *infoDic = @{@&quot;YYKOVObserver&quot; : observer, @&quot;block&quot;: block};
    objc_setAssociatedObject(self, (__bridge const void *)@&quot;YYKVOInfo&quot;, infoDic, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

void YYKVO_setter_block(id self, SEL _cmd, id newValue)
{
    NSString *setterName = NSStringFromSelector(_cmd);
    NSString *getName = getterForSetter(setterName);

    id oldValue = [self valueForKey:getName];

    struct objc_super superClass = {

        .receiver = self,
        .super_class = class_getSuperclass([self class])
    };
    objc_msgSendSuper(&amp;superClass, _cmd, newValue);

    id infoDic = objc_getAssociatedObject(self, (__bridge const void *)@&quot;YYKVOInfo&quot;);
    id observer = [(NSDictionary *)infoDic objectForKey: @&quot;YYKOVObserver&quot;];
    YYObserverBlock block = [(NSDictionary *)infoDic objectForKey: @&quot;block&quot;];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        if (block) {
            block(observer, getName, oldValue, newValue);
        }
    });
}
</code></pre><blockquote>
<p>代码中存在一些硬编码, 主要逻辑就是在添加观察的方法中, 把block和block需要的参数先关联保存起来, 在setter方法中调用block. </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KVO的原理&quot;&gt;&lt;a href=&quot;#KVO的原理&quot; class=&quot;headerlink&quot; title=&quot;KVO的原理&quot;&gt;&lt;/a&gt;KVO的原理&lt;/h2&gt;&lt;p&gt;KVO观察者模式, 指定对象的属性被修改后, KVO就会自动通知相应的观察者. 在项目中的使用步骤可以归纳为
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>runtime在项目中的使用(一)</title>
    <link href="http://yoursite.com/2017/06/08/runtime%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%80)/"/>
    <id>http://yoursite.com/2017/06/08/runtime在项目中的使用(一)/</id>
    <published>2017-06-08T08:00:33.000Z</published>
    <updated>2017-06-12T09:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现NSCoding协议方法"><a href="#实现NSCoding协议方法" class="headerlink" title="实现NSCoding协议方法"></a>实现NSCoding协议方法</h2><blockquote>
<p>在归档自定义的对象时候, 需要自己实现NSCoding协议, 该协议有两个方法需要实现:</p>
</blockquote>
<pre><code>@protocol NSCoding
- (void)encodeWithCoder:(NSCoder *)aCoder;
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER
@end
</code></pre><p>  默认为<code>@required</code> 的, 通常我们的办法是去每个属性都去写一遍, 比如这样:</p>
<pre><code>- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];
    [aCoder encodeObject:self.ID forKey:@&quot;ID&quot;];
}    

- (id)initWithCoder:(NSCoder *)aDecoder
{
   if (self = [super init]) {
       self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
       self.ID= [aDecoder decodeObjectForKey:@&quot;ID&quot;];
    }
   return self;
}
</code></pre><blockquote>
<p>当属性很多后写起来会很繁琐, 而且当我们改了属性的定义后, 方法中的实现也要跟着改, 虽说不是什么难事, 但是这样重复而且无聊的工作实在无趣. 这里引出了使用runtime达到一劳永逸的办法.</p>
</blockquote>
<p><strong>原理就是在运行时通过获取该类的所有属性名称, 然后通过KVC获取到该属性变量的值, 然后调用<code>- (void)encodeObject:(nullable id)objv forKey:(NSString *)key;</code> 和 <code>- (nullable id)decodeObjectForKey:(NSString *)key;</code>达到同样的效果</strong></p>
<blockquote>
<p>实现的代码如下:</p>
</blockquote>
<pre><code>- (void)encodeWithCoder:(NSCoder *)aCoder
{
    unsigned int outCount = 0;
    Ivar *ivars = class_copyIvarList([self class], &amp;outCount);
    for (int i = 0; i &lt; outCount; i ++) {
        Ivar ivar = ivars[i];
        const char *propertyName = ivar_getName(ivar);
        NSString *propertyNameString = [NSString stringWithUTF8String:propertyName];
        id value = [self valueForKey:propertyNameString];
        [aCoder encodeObject:value forKey:propertyNameString];
    }
}

- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (self = [super init]) {
        unsigned int outCount = 0;
        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);
        for (int i = 0; i &lt; outCount; i ++) {
            Ivar ivar = ivars[i];
            const char *propertyName = ivar_getName(ivar);
            NSString *propertyNameString = [NSString stringWithUTF8String:propertyName];
            id value = [aDecoder decodeObjectForKey:propertyNameString];
            [self setValue:value forKey:propertyNameString];
        }
    }
    return self;
}
</code></pre><blockquote>
<p>要使用运行时的函数需要导入头文件<code>#import &lt;objc/message.h&gt;</code><br><code>Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</code> 获取该类的属性的列表, outCount记录了一个有多少个属性. 所以下面for循环就是遍历每个属性.</p>
</blockquote>
<p>在讲到<code>ivar_getName()</code> 函数前,可以先看下Ivar 的定义</p>
<pre><code>typedef struct objc_ivar *Ivar;

struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;
</code></pre><p>一个Ivar的结构体中保存着<em>变量名称</em> 、变量类型、偏移量. 我们在意的就是需要获取到名字，runtime给我们提供了<code>ivar_getName()</code>函数可以获取到.</p>
<p>然后通过KVC获取到属性变量的值,<br><code>id value = [self valueForKey:propertyNameString];</code> </p>
<p><strong>通过测试当属性为<code>NSInteger</code> 或者 <code>int</code> 类型时候一样能使用, 暂时没有发现这样使用存在的问题</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现NSCoding协议方法&quot;&gt;&lt;a href=&quot;#实现NSCoding协议方法&quot; class=&quot;headerlink&quot; title=&quot;实现NSCoding协议方法&quot;&gt;&lt;/a&gt;实现NSCoding协议方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在归档自定义的对象
    
    </summary>
    
    
      <category term="1" scheme="http://yoursite.com/tags/1/"/>
    
  </entry>
  
  <entry>
    <title>自动集成</title>
    <link href="http://yoursite.com/2017/04/10/%E8%87%AA%E5%8A%A8%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2017/04/10/自动集成/</id>
    <published>2017-04-10T07:59:40.000Z</published>
    <updated>2017-04-10T07:59:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LLVM</title>
    <link href="http://yoursite.com/2017/04/10/LLVM/"/>
    <id>http://yoursite.com/2017/04/10/LLVM/</id>
    <published>2017-04-10T07:31:28.000Z</published>
    <updated>2017-04-10T07:31:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
