<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果您发现问题请通知我</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-08T08:24:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime在项目中的使用</title>
    <link href="http://yoursite.com/2017/06/08/runtime%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/08/runtime在项目中的使用/</id>
    <published>2017-06-08T08:00:33.000Z</published>
    <updated>2017-06-08T08:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现NSCoding协议方法"><a href="#实现NSCoding协议方法" class="headerlink" title="实现NSCoding协议方法"></a>实现NSCoding协议方法</h2><blockquote>
<p>在归档自定义的对象时候, 需要自己实现NSCoding协议, 该协议有两个方法需要实现:</p>
</blockquote>
<pre><code>@protocol NSCoding
- (void)encodeWithCoder:(NSCoder *)aCoder;
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER
@end
</code></pre><p>  默认为<code>@required</code> 的, 通常我们的办法是去每个属性都去写一遍, 比如这样:</p>
<pre><code>- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];
    [aCoder encodeObject:self.ID forKey:@&quot;ID&quot;];
}    

- (id)initWithCoder:(NSCoder *)aDecoder
{
   if (self = [super init]) {
       self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
       self.ID= [aDecoder decodeObjectForKey:@&quot;ID&quot;];
    }
   return self;
}
</code></pre><blockquote>
<p>当属性很多后写起来会很繁琐, 而且当我们改了属性的定义后, 方法中的实现也要跟着改, 虽说不是什么难事, 但是这样重复而且无聊的工作实在无趣. 这里引出了使用runtime达到一劳永逸的办法.</p>
</blockquote>
<p><strong>原理就是在运行时通过获取该类的所有属性名称, 然后通过KVC获取到该属性变量的值, 然后调用<code>- (void)encodeObject:(nullable id)objv forKey:(NSString *)key;</code> 和 <code>- (nullable id)decodeObjectForKey:(NSString *)key;</code>达到同样的效果</strong></p>
<blockquote>
<p>实现的代码如下:</p>
</blockquote>
<pre><code>- (void)encodeWithCoder:(NSCoder *)aCoder
{
    unsigned int outCount = 0;
    Ivar *ivars = class_copyIvarList([self class], &amp;outCount);
    for (int i = 0; i &lt; outCount; i ++) {
        Ivar ivar = ivars[i];
        const char *propertyName = ivar_getName(ivar);
        NSString *propertyNameString = [NSString stringWithUTF8String:propertyName];
        id value = [self valueForKey:propertyNameString];
        [aCoder encodeObject:value forKey:propertyNameString];
    }
}

- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (self = [super init]) {
        unsigned int outCount = 0;
        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);
        for (int i = 0; i &lt; outCount; i ++) {
            Ivar ivar = ivars[i];
            const char *propertyName = ivar_getName(ivar);
            NSString *propertyNameString = [NSString stringWithUTF8String:propertyName];
            id value = [aDecoder decodeObjectForKey:propertyNameString];
            [self setValue:value forKey:propertyNameString];
        }
    }
    return self;
}
</code></pre><blockquote>
<p>要使用运行时的函数需要导入头文件<code>#import &lt;objc/message.h&gt;</code><br><code>Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</code> 获取该类的属性的列表, outCount记录了一个有多少个属性. 所以下面for循环就是遍历每个属性.</p>
</blockquote>
<p>在讲到<code>ivar_getName()</code> 函数前,可以先看下Ivar 的定义</p>
<pre><code>typedef struct objc_ivar *Ivar;

struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;
</code></pre><p>一个Ivar的结构体中保存着<em>变量名称</em> 、变量类型、偏移量. 我们在意的就是需要获取到名字，runtime给我们提供了<code>ivar_getName()</code>函数可以获取到.</p>
<p>然后通过KVC获取到属性变量的值,<br><code>id value = [self valueForKey:propertyNameString];</code> </p>
<p><strong>通过测试当属性为<code>NSInteger</code> 或者 <code>int</code> 类型时候一样能使用, 暂时没有发现这样使用存在的问题</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现NSCoding协议方法&quot;&gt;&lt;a href=&quot;#实现NSCoding协议方法&quot; class=&quot;headerlink&quot; title=&quot;实现NSCoding协议方法&quot;&gt;&lt;/a&gt;实现NSCoding协议方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在归档自定义的对象
    
    </summary>
    
    
      <category term="1" scheme="http://yoursite.com/tags/1/"/>
    
  </entry>
  
  <entry>
    <title>自动集成</title>
    <link href="http://yoursite.com/2017/04/10/%E8%87%AA%E5%8A%A8%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2017/04/10/自动集成/</id>
    <published>2017-04-10T07:59:40.000Z</published>
    <updated>2017-04-10T07:59:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LLVM</title>
    <link href="http://yoursite.com/2017/04/10/LLVM/"/>
    <id>http://yoursite.com/2017/04/10/LLVM/</id>
    <published>2017-04-10T07:31:28.000Z</published>
    <updated>2017-04-10T07:31:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
